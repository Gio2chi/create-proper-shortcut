"use strict";
/* IMPORT */
Object.defineProperty(exports, "__esModule", { value: true });
var enums_1 = require("./enums");
var shortcut_1 = require("./shortcut");
var utils_1 = require("./utils");
/* LISTENER */
var Listener = /** @class */ (function () {
    function Listener(options) {
        var _this = this;
        this.lastKeydownID = -1;
        this.currentKeydownShortcutID = [];
        this.currentKeypressShortcutID = [];
        this.currentKeyupShortcutID = [];
        this.resetNextKeydownShortcutID = false;
        this.triggeredNextKeypress = true;
        this.ignoreNextKeypress = false;
        this.listening = false;
        this.handler = function (event) {
            if (!_this.shouldHandleEvent(event))
                return;
            var type = event.type, isKeydown = (type === 'keydown'), isKeypress = (type === 'keypress'), isKeyup = (type === 'keyup');
            if (isKeydown) { // Resetting, in case two keydown events get triggered in a row
                _this.ignoreNextKeypress = false;
            }
            if (isKeypress && _this.ignoreNextKeypress) { // Ignoring this keypress, already handled on keydown
                _this.triggeredNextKeypress = true;
                return;
            }
            var id = shortcut_1.default.event2id(event), triggerKey = shortcut_1.default.getTriggerKey(id);
            if (isKeydown) {
                _this.lastKeydownID = id;
            }
            if (isKeyup && (triggerKey || id !== _this.lastKeydownID)) { // Keyup only handles no-trigger events, if no other shortcuts with triggers have been triggered before, if no other keys havve been registered on keyPress
                _this.currentKeyupShortcutID.length = 0;
                return;
            }
            if (!isKeyup && !triggerKey)
                return; // Only keyup handles non-trigger events
            var shortcutID = isKeydown ? _this.currentKeydownShortcutID : (isKeyup ? _this.currentKeyupShortcutID : _this.currentKeypressShortcutID);
            if (isKeydown && !_this.resetNextKeydownShortcutID && !_this.triggeredNextKeypress) { // A chord triggered on keydown didn't get triggered on keypress also, so we copy it over manually
                _this.currentKeypressShortcutID.push(_this.currentKeydownShortcutID[_this.currentKeydownShortcutID.length - 1]);
            }
            if (isKeydown && _this.resetNextKeydownShortcutID) { // Resetting keydown shortcut id
                shortcutID.length = 0;
                _this.resetNextKeydownShortcutID = false;
            }
            shortcutID.push(id);
            if (isKeypress && utils_1.default.isEqual(_this.currentKeydownShortcutID, shortcutID)) { // Avoiding handling keypress for the same detected shortcut in order to maximize performance. Unless the handler for this shortcut has been added between keydown and keypress (weird) this won't be a problem
                if (_this.resetNextKeydownShortcutID) {
                    _this.currentKeypressShortcutID.length = 0;
                }
                _this.triggeredNextKeypress = true;
                return;
            }
            var result = _this.options.handler(shortcutID, event);
            if (result === enums_1.ListenerResult.HANDLED) { // Resetting all shortcuts
                _this.resetNextKeydownShortcutID = true;
                _this.currentKeypressShortcutID.length = 0;
                _this.currentKeyupShortcutID.length = 0;
            }
            else if (result === enums_1.ListenerResult.UNHANDLEABLE) { // Resetting only the current shortcut
                if (isKeydown) {
                    _this.resetNextKeydownShortcutID = true;
                }
                else if (isKeypress) {
                    _this.currentKeypressShortcutID.length = 0;
                }
                else if (isKeyup) {
                    _this.currentKeyupShortcutID.length = 0;
                }
            }
            else if (typeof result === 'object') { // Changing the current shortcut
                shortcutID.splice.apply(// Changing the current shortcut
                shortcutID, [0, Infinity].concat(result));
            }
            if (!isKeyup) {
                _this.ignoreNextKeypress = isKeydown && result === enums_1.ListenerResult.HANDLED;
                _this.triggeredNextKeypress = isKeypress;
            }
        };
        this.options = options;
        this.capture = !!options.capture;
        this.target = options.target || document;
        this.shouldHandleEvent = options.shouldHandleEvent || (function (event) { return !event.defaultPrevented; });
    }
    Listener.prototype.on = function () {
        if (this.listening)
            return;
        this.listening = true;
        this.target.addEventListener('keydown', this.handler, { capture: this.capture });
        this.target.addEventListener('keypress', this.handler, { capture: this.capture });
        this.target.addEventListener('keyup', this.handler, { capture: this.capture });
    };
    Listener.prototype.off = function () {
        if (!this.listening)
            return;
        this.listening = false;
        this.target.removeEventListener('keydown', this.handler, { capture: this.capture });
        this.target.removeEventListener('keypress', this.handler, { capture: this.capture });
        this.target.removeEventListener('keyup', this.handler, { capture: this.capture });
    };
    Listener.prototype.isListening = function () {
        return this.listening;
    };
    return Listener;
}());
/* EXPORT */
exports.default = Listener;
